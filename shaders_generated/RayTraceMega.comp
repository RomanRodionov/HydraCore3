#version 460
#extension GL_GOOGLE_include_directive : require

#include "common_generated.h"

layout(binding = 0, set = 0) buffer data0 { vec4 out_color[]; }; //
layout(binding = 1, set = 0) buffer dataUBO { Integrator_Generated_UBO_Data ubo; };

vec4 GetEnvironmentColorAndPdf(vec3 a_dir) {
  return ubo.m_envColor;
}

bool isOutOfScene(uint a_flags) { return (a_flags & RAY_FLAG_OUT_OF_SCENE)   != 0; }

BsdfSample MaterialSampleWhitted(uint a_materialId, vec3 v, vec3 n, vec2 tc) { 
  const uint  type       = as_uint(m_materials[a_materialId].data[UINT_MTYPE]);
  const float3 specular  = to_float3(m_materials[a_materialId].colors[GLTF_COLOR_METAL]);
  const float3 coat      = to_float3(m_materials[a_materialId].colors[GLTF_COLOR_COAT]);
  const float  roughness = 1.0f - m_materials[a_materialId].data[GLTF_FLOAT_GLOSINESS];
  float alpha            = m_materials[a_materialId].data[GLTF_FLOAT_ALPHA];
  
  const vec3 pefReflDir = reflect((-1.0f)*v, n);
  const vec3 reflColor = alpha*specular + (1.0f - alpha)*coat;

  //if(a_materialId == 4)
  //{
  //  int a = 2;
  //}

  BsdfSample res;
  res.dir   = pefReflDir;
  res.val   = reflColor;
  res.pdf   = 1.0f;
  res.flags = RAY_EVENT_S;
  return res;
}

uint extractMatId(uint a_flags) { return (a_flags & 0x00FFFFFF); }

bool isDeadRay(uint a_flags) { return (a_flags & RAY_FLAG_IS_DEAD)        != 0; }

float LightPdfSelectRev(int a_lightId) { 
  return 1.0f/float(m_lights.size()); // uniform select
}

vec3 GetLightSourceIntensity(uint a_lightId, in vec3 a_wavelengths) {
  float3 lightColor = to_float3(m_lights[a_lightId].intensity);
  if(!ubo.m_spectral_mode)
    return lightColor;

  const uint specId = as_uint(m_lights[a_lightId].ids.x);

  if(specId < 0xFFFFFFFF)
  {
    lightColor = SampleSpectrum(m_spectra.data() + specId, *a_wavelengths);
    // const uint spectralSamples = uint(sizeof(a_wavelengths->M) / sizeof(a_wavelengths->M[0])); 
    // for(uint i = 0; i < spectralSamples; ++i)
    //   lightColor[i] = m_spectra[specId].Sample(a_wavelengths->M[i]);
  }
  return lightColor;
}

BsdfEval MaterialEval(uint a_materialId, vec3 wavelengths, vec3 l, vec3 v, vec3 n, vec2 tc) {
  // explicit strategy
  const float2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const uint   mtype     = as_uint(m_materials[a_materialId].data[UINT_MTYPE]);

  // TODO: read other parameters from texture
  BsdfEval res;
  {
    res.val = vec3(0,0,0);
    res.pdf   = 0.0f;
  }

  switch(mtype)
  {
    case MAT_TYPE_GLTF:
    {
      const uint   texId     = as_uint(m_materials[a_materialId].data[GLTF_UINT_TEXID0]);
      const float3 texColor  = to_float3(m_textures[texId]->sample(texCoordT));
      const float3 color     = to_float3(m_materials[a_materialId].colors[GLTF_COLOR_BASE])*texColor;
      gltfEval(m_materials.data() + a_materialId, l, v, n, tc, color, &res);
      break;
    }
    case MAT_TYPE_GLASS:
    {
      glassEval(m_materials.data() + a_materialId, l, v, n, tc, {}, &res);
      break;
    }
    case MAT_TYPE_CONDUCTOR: 
    {
      const uint   texId     = as_uint(m_materials[a_materialId].data[CONDUCTOR_TEXID0]);
      const float3 alphaTex  = to_float3(m_textures[texId]->sample(texCoordT));

      const float2 alpha = float2(m_materials[a_materialId].data[CONDUCTOR_ROUGH_V], m_materials[a_materialId].data[CONDUCTOR_ROUGH_U]);
      if(trEffectivelySmooth(alpha))
        conductorSmoothEval(m_materials.data() + a_materialId, wavelengths, l, v, n, tc, &res);
      else
        conductorRoughEval(m_materials.data() + a_materialId, m_spectra.data(), wavelengths, l, v, n, tc, alphaTex, &res);

      break;
    }
    case MAT_TYPE_DIFFUSE:
    {
      const uint   texId       = as_uint(m_materials[a_materialId].data[DIFFUSE_TEXID0]);
      // const float3 reflectance = to_float3(m_materials[a_materialId].colors[DIFFUSE_COLOR]); 
      const float3 texColor    = to_float3(m_textures[texId]->sample(texCoordT));
      const vec3 color = texColor;

      diffuseEval(m_materials.data() + a_materialId, m_spectra.data(), wavelengths, l, v, n, tc, color, &res);

      break;
    }
    default:
      break;
  }

  return res;
}

float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, const vec3 lpos, const vec3 lnorm) {
  const uint gtype    = m_lights[a_lightId].geomType;
  const float hitDist = length(illuminationPoint - lpos);
  
  float cosVal = 1.0f;
  switch(gtype)
  {
    case LIGHT_GEOM_SPHERE:
    {
      const float  lradius = m_lights[a_lightId].size.x;
      const float3 lcenter = to_float3(m_lights[a_lightId].pos);
      //if (DistanceSquared(illuminationPoint, lcenter) - lradius*lradius <= 0.0f)
      //  return 1.0f;
      const vec3 dirToV = normalize(lpos - illuminationPoint);
      cosVal = std::abs(dot(dirToV, lnorm));
    }
    break;

    default:
    cosVal  = std::max(dot(ray_dir, -1.0f*lnorm), 0.0f);
    break;
  };
  
  return PdfAtoW(m_lights[a_lightId].pdfA, hitDist, cosVal);
}

LightSample LightSampleRev(int a_lightId, vec2 rands, vec3 illiminationPoint) {
  const uint gtype = m_lights[a_lightId].geomType;
  switch(gtype)
  {
    case LIGHT_GEOM_DIRECT: return directLightSampleRev(m_lights.data() + a_lightId, rands, illiminationPoint);
    case LIGHT_GEOM_SPHERE: return sphereLightSampleRev(m_lights.data() + a_lightId, rands);
    default:                return areaLightSampleRev  (m_lights.data() + a_lightId, rands);
  };
}

BsdfSample MaterialSampleAndEval(uint a_materialId, vec3 wavelengths, vec4 rands, vec3 v, vec3 n, vec2 tc, inout MisData a_misPrev, const uint a_currRayFlags) {
  // implicit strategy
  const float2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const uint   mtype     = as_uint(m_materials[a_materialId].data[UINT_MTYPE]);

  // TODO: read other parameters from texture

  BsdfSample res;
  {
    res.val   = vec3(0,0,0);
    res.pdf   = 1.0f;
    res.dir   = vec3(0,1,0);
    res.flags = a_currRayFlags;
  }


  switch(mtype)
  {
    case MAT_TYPE_GLTF:
    {
      const uint   texId     = as_uint(m_materials[a_materialId].data[GLTF_UINT_TEXID0]);
      const float3 texColor  = to_float3(m_textures[texId]->sample(texCoordT));
      const float3 color     = to_float3(m_materials[a_materialId].colors[GLTF_COLOR_BASE])*texColor;
      gltfSampleAndEval(m_materials.data() + a_materialId, rands, v, n, tc, color, &res);
      break;
    }
    case MAT_TYPE_GLASS:
    {
      glassSampleAndEval(m_materials.data() + a_materialId, rands, v, n, tc, &res, a_misPrev);
      break;
    }
    case MAT_TYPE_CONDUCTOR:
    {
      const uint   texId     = as_uint(m_materials[a_materialId].data[CONDUCTOR_TEXID0]);
      const float2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
      const float3 alphaTex  = to_float3(m_textures[texId]->sample(texCoordT));
      
      const float2 alpha = float2(m_materials[a_materialId].data[CONDUCTOR_ROUGH_V], m_materials[a_materialId].data[CONDUCTOR_ROUGH_U]);
      if(trEffectivelySmooth(alpha))
        conductorSmoothSampleAndEval(m_materials.data() + a_materialId, m_spectra.data(), wavelengths, rands, v, n, tc, &res);
      else
        conductorRoughSampleAndEval(m_materials.data() + a_materialId, m_spectra.data(), wavelengths, rands, v, n, tc, alphaTex, &res);
      
      break;
    }
    case MAT_TYPE_DIFFUSE:
    {
      const uint   texId       = as_uint(m_materials[a_materialId].data[DIFFUSE_TEXID0]);
      // const float3 reflectance = to_float3(m_materials[a_materialId].colors[DIFFUSE_COLOR]); 
      const float3 texColor    = to_float3(m_textures[texId]->sample(texCoordT));
      const vec3 color = texColor;

      diffuseSampleAndEval(m_materials.data() + a_materialId, m_spectra.data(), wavelengths, rands, v, n, tc, color, &res);

      break;
    }
    default:
      break;
  }

  return res;
}

bool hasNonSpecular(uint a_flags) { return (a_flags & RAY_FLAG_HAS_NON_SPEC)   != 0; }

uint packMatId(uint a_flags, uint a_matId) { return (a_flags & 0xFF000000) | (a_matId & 0x00FFFFFF); }

uint RemapMaterialId(uint a_mId, int a_instId) {
  const int remapListId  = m_remapInst[a_instId];
  if(remapListId == -1)
    return a_mId;

  const int r_offset     = m_allRemapListsOffsets[remapListId];
  const int r_size       = m_allRemapListsOffsets[remapListId+1] - r_offset;
  const ivec2 offsAndSize = ivec2(r_offset,r_size);
  
  uint res = a_mId;
  
  // for (int i = 0; i < offsAndSize.y; i++) // linear search version
  // {
  //   int idRemapFrom = m_allRemapLists[offsAndSize.x + i * 2 + 0];
  //   int idRemapTo   = m_allRemapLists[offsAndSize.x + i * 2 + 1];
  //   if (idRemapFrom == a_mId) {
  //     res = idRemapTo;
  //     break;
  //   }
  // }

  int low  = 0;
  int high = offsAndSize.y - 1;              // binary search version
  
  while (low <= high)
  {
    const int mid         = low + ((high - low) / 2);
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + mid * 2 + 0];
    if (uint(idRemapFrom) >= a_mId)
      high = mid - 1;
    else //if(a[mid]<i)
      low = mid + 1;
  }

  if (high+1 < offsAndSize.y)
  {
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 0];
    const int idRemapTo   = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 1];
    res                   = (uint(idRemapFrom) == a_mId) ? uint(idRemapTo) : a_mId;
  }

  return res;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_RayBounce(uint tid, uint bounce, in vec4 in_hitPart1, in vec4 in_hitPart2, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar, inout vec4 accumColor, inout vec4 accumThoroughput, inout uint rayFlags) 
{
  
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;

  const uint matId = extractMatId(currRayFlags);

  // process surface hit case
  //
  const vec3 ray_dir = rayDirAndFar.xyz;
  //const float3 ray_pos = to_float3(*rayPosAndNear);

  const vec4 data1 = in_hitPart1;
  const vec4 data2 = in_hitPart2;

  SurfaceHit hit;
  hit.pos  = data1.xyz;
  hit.norm = data2.xyz;
  hit.uv   = vec2(data1.w,data2.w);

  // process light hit case
  //
  if(as_uint(m_materials[matId].data[UINT_MTYPE]) == MAT_TYPE_LIGHT_SOURCE)
  {
    const uint   texId          = as_uint(m_materials[matId].data[GLTF_UINT_TEXID0]);
    const float2 texCoordT      = mulRows2x4(m_materials[matId].row0[0], m_materials[matId].row1[0], hit.uv);
    const float3 texColor       = to_float3(m_textures[texId]->sample(texCoordT));

    const float3 lightIntensity = to_float3(m_materials[matId].colors[GLTF_COLOR_BASE])*texColor;
    const uint lightId          = as_uint(m_materials[matId].data[UINT_LIGHTID]);
    float lightDirectionAtten   = (lightId == 0xFFFFFFFF) ? 1.0f : dot(rayDirAndFar.xyz, vec3(0,-1,0)) < 0.0f ? 1.0f : 0.0f; // TODO: read light info, gety light direction and e.t.c;


    vec4 currAccumColor = accumColor;
    vec4 currAccumThroughput = accumThoroughput;

    currAccumColor.x += currAccumThroughput.x * lightIntensity.x * lightDirectionAtten;
    currAccumColor.y += currAccumThroughput.y * lightIntensity.y * lightDirectionAtten;
    currAccumColor.z += currAccumThroughput.z * lightIntensity.z * lightDirectionAtten;

    accumColor = currAccumColor;
    rayFlags   = currRayFlags | (RAY_FLAG_IS_DEAD | RAY_FLAG_HIT_LIGHT);
    return;
  }

  vec4 shadeColor = vec4(0.0f,0.0f,0.0f,1.0f);
  for(uint lightId = 0; lightId < m_lights.size(); ++lightId)
  {
    const float3 lightPos = to_float3(m_lights[lightId].pos);
    const float hitDist   = sqrt(dot(hit.pos - lightPos, hit.pos - lightPos));

    const float3 shadowRayDir = normalize(lightPos - hit.pos);
    const float3 shadowRayPos = hit.pos + hit.norm * std::max(maxcomp(hit.pos), 1.0f) * 5e-6f; // TODO: see Ray Tracing Gems, also use flatNormal for offset

    const bool inShadow = m_pAccelStruct->RayQuery_AnyHit(to_float4(shadowRayPos, 0.0f), to_float4(shadowRayDir, hitDist * 0.9995f));

    if(!inShadow && dot(shadowRayDir, to_float3(m_lights[lightId].norm)) < 0.0f)
    {
      const float3 matSamColor = MaterialEvalWhitted(matId, shadowRayDir, (-1.0f)*ray_dir, hit.norm, hit.uv);
      const float cosThetaOut  = std::max(dot(shadowRayDir, hit.norm), 0.0f);
      shadeColor += to_float4(to_float3(m_lights[lightId].intensity) * matSamColor*cosThetaOut / (hitDist * hitDist), 0.0f);
    }
  }

  const BsdfSample matSam = MaterialSampleWhitted(matId, (-1.0f)*ray_dir, hit.norm, hit.uv);
  const vec3 bxdfVal = matSam.val;
  const float  cosTheta   = dot(matSam.dir, hit.norm);

  const vec4 currThoroughput = accumThoroughput;
  vec4 currAccumColor = accumColor;

  currAccumColor.x += currThoroughput.x * shadeColor.x;
  currAccumColor.y += currThoroughput.y * shadeColor.y;
  currAccumColor.z += currThoroughput.z * shadeColor.z;

  accumColor       = currAccumColor;
  accumThoroughput = currThoroughput * cosTheta * vec4(bxdfVal, 0.0f);

  rayPosAndNear = vec4(OffsRayPos(hit.pos, hit.norm, matSam.dir), 0.0f);
  rayDirAndFar  = vec4(matSam.dir, FLT_MAX);
  rayFlags      = currRayFlags | matSam.flags;

}

void kernel_RayTrace2(uint tid, in vec4 rayPosAndNear, in vec4 rayDirAndFar, inout vec4 out_hit1, inout vec4 out_hit2, inout uint out_instId, inout uint rayFlags) 
{
  
  uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const vec4 rayPos = rayPosAndNear;
  const vec4 rayDir = rayDirAndFar ;

  const CRT_Hit hit   = m_pAccelStruct->RayQuery_NearestHit(rayPos, rayDir);

  if(hit.geomId != uint32_t(-1))
  {
    const vec2 uv = vec2(hit.coords[0],hit.coords[1]);
    const vec3 hitPos = rayPos.xyz + (hit.t*0.999999f)*rayDir.xyz; // set hit slightlyt closer to old ray origin to prevent self-interseaction and e.t.c bugs

    const uint triOffset  = m_matIdOffsets[hit.geomId];
    const uint vertOffset = m_vertOffset  [hit.geomId];
  
    const uint A = m_triIndices[(triOffset + hit.primId)*3 + 0];
    const uint B = m_triIndices[(triOffset + hit.primId)*3 + 1];
    const uint C = m_triIndices[(triOffset + hit.primId)*3 + 2];
  
    const float3 A_norm = to_float3(m_vNorm4f[A + vertOffset]);
    const float3 B_norm = to_float3(m_vNorm4f[B + vertOffset]);
    const float3 C_norm = to_float3(m_vNorm4f[C + vertOffset]);

    const float2 A_texc = m_vTexc2f[A + vertOffset];
    const float2 B_texc = m_vTexc2f[B + vertOffset];
    const float2 C_texc = m_vTexc2f[C + vertOffset];
      
    vec3 hitNorm = (1.0f - uv.x - uv.y)*A_norm + uv.y*B_norm + uv.x*C_norm;
    vec2 hitTexCoord = (1.0f - uv.x - uv.y)*A_texc + uv.y*B_texc + uv.x*C_texc;
  
    // transform surface point with matrix and flip normal if needed
    //
    hitNorm                = normalize(mul3x3(m_normMatrices[hit.instId], hitNorm));
    const float flipNorm   = dot(rayDir.xyz, hitNorm) > 0.001f ? -1.0f : 1.0f; // beware of transparent materials which use normal sign to identity "inside/outside" glass for example
    hitNorm                = flipNorm * hitNorm;
    
    if (flipNorm < 0.0f) currRayFlags |=  RAY_FLAG_HAS_INV_NORMAL;
    else                 currRayFlags &= ~RAY_FLAG_HAS_INV_NORMAL;

    const uint midOriginal = m_matIdByPrimId[m_matIdOffsets[hit.geomId] + hit.primId];
    const uint midRemaped  = RemapMaterialId(midOriginal, int(hit.instId));

    rayFlags              = packMatId(currRayFlags, midRemaped);
    out_hit1              = vec4(hitPos, hitTexCoord.x); 
    out_hit2              = vec4(hitNorm, hitTexCoord.y);
    out_instId            = hit.instId;
  }
  else
    rayFlags              = currRayFlags | (RAY_FLAG_IS_DEAD | RAY_FLAG_OUT_OF_SCENE);

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tid = uint(gl_GlobalInvocationID[0]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  vec4 accumColor,  accumThroughput;
  vec4 rayPosAndNear,  rayDirAndFar;
  uint      rayFlags = 0;
  kernel_InitEyeRay3(tid, m_packedXY.data(), 
                     &rayPosAndNear, &rayDirAndFar, &accumColor, &accumThroughput, &rayFlags);

  for(uint depth = 0; depth < ubo.m_traceDepth; depth++)
  {
    vec4 hitPart1,  hitPart2;
    uint instId;
    kernel_RayTrace2(tid, rayPosAndNear, rayDirAndFar, hitPart1, hitPart2, instId, rayFlags);
    if(isDeadRay(rayFlags))
      break;

    kernel_RayBounce(tid, depth, hitPart1, hitPart2,
                     rayPosAndNear, rayDirAndFar, accumColor, accumThroughput, rayFlags);

    if(isDeadRay(rayFlags))
      break;
  }

//  kernel_HitEnvironment(tid, &rayFlags, &rayDirAndFar, &mis, &accumThroughput,
//                        &accumColor);

  kernel_ContributeToImage3(tid, &accumColor, m_packedXY.data(), out_color);

}

